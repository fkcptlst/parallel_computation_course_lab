#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <iostream>
#include <fstream>
#include <math.h>
#include "assert.h"

const int MAX_SIZE = 1000;
const int MAX_MAT_DIM = 1000;
const int MAX_KERNEL_DIM = 10;

int N;
int mat_dim, kernel_dim;
int T; // number of threads
int BLOCK_SIZE = 0;  // block size

int matrix[MAX_MAT_DIM + 2][MAX_MAT_DIM + 2];
int kernel[MAX_KERNEL_DIM][MAX_KERNEL_DIM];
int result[MAX_MAT_DIM][MAX_MAT_DIM];

struct thread_data
{
    int thread_id;
    int begin_row, begin_col;  // corresponding to the result matrix section which the thread is responsible for
    int end_row, end_col;  // left inclusive, right exclusive
} thread_data_array[MAX_SIZE];

void* thread_function(void* arg);


int main(int arg, char *argv[])
{
    if (arg != 5)
    {
        printf("Usage: parallel.exe <N> <matrix dimension> <kernel dimension> <number of threads>");
        exit(1);
    }

    N = atoi(argv[1]);
    mat_dim = atoi(argv[2]);
    kernel_dim = atoi(argv[3]);
    T = atoi(argv[4]);

    BLOCK_SIZE = (mat_dim + 2) / sqrt(T);
    // printf("BLOCK_SIZE = %d\n", BLOCK_SIZE);
    // assert BLOCK_SIZE is larger than kernel_dim
    assert(BLOCK_SIZE >= kernel_dim);
    // assert mat_dim + 2 is divisible by BLOCK_SIZE
    assert((mat_dim + 2) % BLOCK_SIZE == 0);

    int row_block_num = (mat_dim + 2) / BLOCK_SIZE;
    int col_block_num = (mat_dim + 2) / BLOCK_SIZE;

    // printf("row_block_num = %d, col_block_num = %d\n", row_block_num, col_block_num);

    pthread_t threads[T];



    // read in the matrix from matrix.txt
    std::ifstream mat_file("matrix.txt");
    for (int i = 0; i < mat_dim + 2; i++)
    {
        for (int j = 0; j < mat_dim + 2; j++)
        {
            matrix[i][j] = 0;
        }
    }
    for (int i = 1; i < mat_dim + 1; i++)
        for (int j = 1; j < mat_dim + 1; j++)
            mat_file >> matrix[i][j];
    mat_file.close();

    // read in the kernel from kernel.txt
    std::ifstream kernel_file("kernel.txt");
    for (int i = 0; i < kernel_dim; i++)
    {
        for (int j = 0; j < kernel_dim; j++)
        {
            kernel_file >> kernel[i][j];
        }
    }
    kernel_file.close();

    // initialize result
    for (int i = 0; i < mat_dim; i++)
    {
        for (int j = 0; j < mat_dim; j++)
        {
            result[i][j] = 0;
        }
    }

    int thread_id[T];
    for(int t = 0; t < T; t++)
    {
        thread_id[t] = t;

        thread_data_array[t].thread_id = t;
        thread_data_array[t].begin_row = (t / row_block_num) * BLOCK_SIZE;
        thread_data_array[t].begin_col = (t % col_block_num) * BLOCK_SIZE;
        thread_data_array[t].end_row = thread_data_array[t].begin_row + BLOCK_SIZE;
        thread_data_array[t].end_col = thread_data_array[t].begin_col + BLOCK_SIZE;

        // printf("Thread %d: begin_row = %d, begin_col = %d\n", t, thread_data_array[t].begin_row, thread_data_array[t].begin_col);

        pthread_create(&threads[t], NULL, thread_function, &thread_id[t]);
    }
    
    // wait for all threads to finish
    for(int t = 0; t < T; t++)
    {
        pthread_join(threads[t], NULL);
    }    

    // write result to result_parallel.txt
    std::ofstream result_file("result_parallel.txt");
    for (int i = 0; i < mat_dim; i++)
    {
        for (int j = 0; j < mat_dim; j++)
        {
            result_file << result[i][j] << "\t";
        }
        result_file << std::endl;
    }
}

void* thread_function(void* arg) {
    int id = *(int*)arg;
    
    for(int i = thread_data_array[id].begin_row; i < thread_data_array[id].end_row; i++)
    {
        for(int j = thread_data_array[id].begin_col; j < thread_data_array[id].end_col; j++)
        {
            for(int i_ = 0; i_ < kernel_dim; i_++)
            {
                for(int j_ = 0; j_ < kernel_dim; j_++)
                {
                    result[i][j] += matrix[i + i_][j + j_] * kernel[i_][j_];
                }
            }
        }
    }

    return NULL;
}